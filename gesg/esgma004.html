<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ·¨é›¶è³½å±€ï¼šç¶ è‰²ä½µè³¼ (Net Zero Merger) - Refactored</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>
    <style>
        body { font-family: 'Noto Sans TC', sans-serif; background-color: #f0f4f8; }
        .tile-grid { display: grid; grid-template-columns: repeat(10, 1fr); gap: 2px; }
        .animate-pulse-fast { animation: pulse 1s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: .5; } }
        .shimmer {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }
        @keyframes shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;

        // --- 14. Magic Numbers & Constants ---
        const CONSTANTS = {
            GRID_SIZE: 10,
            INITIAL_MONEY: 6000,
            HAND_SIZE: 6,
            BASE_GREEN_COST: 200,
            FOUNDER_BONUS_STOCK: 1,
            MAX_STOCKS_PER_TURN: 3,
            EVENT_INTERVAL: 2,
            MERGER_BONUS_MULTIPLIER: 10,
            HOSTILE_TAKEOVER_SIZE_DIFF: 3,
            EVENT_DEFAULT_DURATION: 3 // äº‹ä»¶é è¨­æŒçºŒ3å€‹å›åˆ(ç¸½è¨ˆ)
        };

        const COMPANIES_DATA = [
            { id: 1, name: 'æ³°å¦èƒ½æº', color: 'bg-red-500', textColor: 'text-red-600', lightColor: 'bg-red-100' },
            { id: 2, name: 'å·¨ç¥é‡å·¥', color: 'bg-yellow-500', textColor: 'text-yellow-600', lightColor: 'bg-yellow-100' },
            { id: 3, name: 'ç’°çƒèˆªé‹', color: 'bg-blue-500', textColor: 'text-blue-600', lightColor: 'bg-blue-100' },
            { id: 4, name: 'é ‚å³°ç§‘æŠ€', color: 'bg-purple-500', textColor: 'text-purple-600', lightColor: 'bg-purple-100' },
            { id: 5, name: 'è¯åˆç”ŸæŠ€', color: 'bg-orange-500', textColor: 'text-orange-600', lightColor: 'bg-orange-100' },
            { id: 6, name: 'æ¥µå…‰ç¶ èƒ½', color: 'bg-teal-500', textColor: 'text-teal-600', lightColor: 'bg-teal-100' },
            { id: 7, name: 'æ–°æ˜Ÿå»ºè¨­', color: 'bg-pink-500', textColor: 'text-pink-600', lightColor: 'bg-pink-100' },
        ];

        const REGULATION_CARDS = [
            { id: 1, title: "CBAM æ©Ÿåˆ¶å•Ÿå‹•", desc: "é«˜ç¢³æ’ä¼æ¥­(Cç´š)è‚¡åƒ¹ä¸‹è·Œ $200ã€‚", effectType: "PRICE_MOD", targetTier: "C", amount: -200, instant: false, duration: 4 },
            { id: 2, title: "ç¢³ç¨…ç¿»å€", desc: "ç«‹å³å°æŒæœ‰ C ç´šè‚¡ç¥¨çš„æŠ•è³‡äººé–‹ç½° $50/å¼µã€‚", effectType: "FINE", targetTier: "C", amount: 50, instant: true },
            { id: 3, title: "ç¶ è‰²æŠ€è¡“çªç ´", desc: "å»ºè¨­ç¶ è‰²è£½ç¨‹å…è²»ã€‚", effectType: "COST_MOD", cost: 0, instant: false, duration: 3 },
            { id: 4, title: "æ¼‚ç¶ é†œè", desc: "æœ€å¤§ B ç´šå…¬å¸è‚¡åƒ¹é‡æŒ« $300ã€‚", effectType: "SCANDAL_B", amount: -300, instant: false, duration: 4 },
            { id: 5, title: "ç¢³æ¬Šè£œåŠ©", desc: "A ç´šå…¬å¸æœ€å¤§è‚¡æ±ç² $500 çå‹µã€‚", effectType: "SUBSIDY_MAJOR", targetTier: "A", amount: 500, instant: true },
            { id: 6, title: "åŒ–çŸ³æ’¤è³‡", desc: "C ç´šä¼æ¥­è‚¡åƒ¹ä¸‹è·Œ $100ã€‚", effectType: "PRICE_MOD", targetTier: "C", amount: -100, instant: false, duration: 5 },
            { id: 7, title: "ç¶ é›»åˆ©å¥½", desc: "A ç´šä¼æ¥­è‚¡åƒ¹ä¸Šæ¼² $200ã€‚", effectType: "PRICE_MOD", targetTier: "A", amount: 200, instant: false, duration: 5 },
            { id: 8, title: "ESG è©•ç´šç·Šç¸®", desc: "Bã€C ç´šä¼æ¥­è‚¡åƒ¹ä¸‹è·Œ $100ã€‚", effectType: "PRICE_MOD_MULTI", targetTiers: ["B", "C"], amount: -100, instant: false, duration: 4 },
            { id: 9, title: "ç¶ è‰²ä¿¡è²¸", desc: "æŒæœ‰æœ€å¤š A ç´šè‚¡ç¥¨è€…ç² $1000ã€‚", effectType: "BONUS_MOST_A", amount: 1000, instant: true },
            { id: 10, title: "æ¥µç«¯æ°£å€™", desc: "æ‰€æœ‰å…¬å¸è‚¡åƒ¹ä¸‹è·Œ $50ã€‚", effectType: "PRICE_MOD_ALL", amount: -50, instant: false, duration: 3 },
            { id: 11, title: "äººæ‰çŸ­ç¼º", desc: "ç¶ è‰²è£½ç¨‹å»ºè¨­æˆæœ¬æš´æ¼²è‡³ $400ã€‚", effectType: "COST_MOD", cost: 400, instant: false, duration: 4 },
            { id: 12, title: "å¾ªç’°ç´…åˆ©", desc: "A ç´šä¼æ¥­ç™¼æ”¾è‚¡åˆ© $50/å¼µã€‚", effectType: "DIVIDEND", targetTier: "A", amount: 50, instant: true },
            { id: 13, title: "æ°£å€™å³°æœƒ", desc: "Aã€B ç´šä¼æ¥­è‚¡åƒ¹ä¸Šæ¼² $100ã€‚", effectType: "PRICE_MOD_MULTI", targetTiers: ["A", "B"], amount: 100, instant: false, duration: 5 },
            { id: 14, title: "åš´æ ¼ç¨½æ ¸", desc: "C ç´šä¼æ¥­ç¦æ­¢è‚¡ç¥¨è²·å…¥ä¸”è‚¡åƒ¹ä¸‹è·Œ $150ã€‚", effectType: "RESTRICT_AND_DROP", targetTier: "C", amount: -150, instant: false, duration: 3 },
            { id: 15, title: "å»ºè¨­è£œè²¼", desc: "å»ºè¨­ç°è‰²è£½ç¨‹ç² $100 è£œè²¼ã€‚", effectType: "GREY_SUBSIDY", amount: 100, instant: false, duration: 3 },
        ];

        // --- Utilities ---
        const getCoordString = (index) => {
            const row = Math.floor(index / CONSTANTS.GRID_SIZE);
            const col = index % CONSTANTS.GRID_SIZE;
            const letters = "ABCDEFGHIJ";
            return `${letters[row]}${col + 1}`;
        };

        const shuffleArray = (array) => {
            const newArr = [...array];
            for (let i = newArr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArr[i], newArr[j]] = [newArr[j], newArr[i]];
            }
            return newArr;
        };

        // --- 8. Performance: Memoized Tile Component ---
        const Tile = React.memo(({ index, cell, active, playable, onClick, companies }) => {
            const company = cell && cell.ownerId ? companies.find(c => c.id === cell.ownerId) : null;
            
            return (
                <div onClick={onClick} 
                    className={`relative border border-white flex items-center justify-center text-[10px] sm:text-xs transition-all select-none
                    ${cell ? (cell.ownerId && company ? company.color : 'bg-gray-800') : 'bg-gray-100'}
                    ${cell && cell.type === 'green' ? 'ring-2 ring-green-300 ring-inset' : ''}
                    ${active ? 'ring-4 ring-yellow-400 z-10 scale-110 shadow-lg' : ''}
                    ${playable ? 'hover:bg-gray-200 cursor-pointer' : 'cursor-default'}`}
                >
                    <span className={cell?.ownerId ? 'text-white font-bold' : 'text-gray-400'}>{getCoordString(index)}</span>
                    {cell?.type === 'green' && <span className="absolute top-0 right-0 text-[10px] leading-none p-0.5">ğŸŒ¿</span>}
                    {cell?.type === 'grey' && <span className="absolute top-0 right-0 text-[10px] leading-none p-0.5">ğŸ­</span>}
                </div>
            );
        }, (prev, next) => {
            return prev.cell === next.cell && 
                   prev.active === next.active && 
                   prev.playable === next.playable &&
                   prev.companies === next.companies; // Deep compare companies might be expensive, strictly usually ref check is enough if companies immutable
        });

        // --- API Service with Mock ---
        const AiService = {
            async callGemini(prompt, userKey) {
                if (!userKey) {
                    // Mock response for safety and no-key scenarios
                    return new Promise(resolve => {
                        setTimeout(() => {
                            if (prompt.includes("æ–°è")) resolve("ã€å¸‚å ´å¿«è¨Šã€‘ç¥ç§˜è²¡åœ˜å¤§èˆ‰ä½µè³¼ï¼Œåˆ†æå¸«æŒ‡å‡ºå¸‚å ´å°‡é¢è‡¨é‡æ–°æ´—ç‰Œï¼(æ¨¡æ“¬æ–°è)");
                            else if (prompt.includes("å»ºè­°")) resolve("æ ¹æ“šç›®å‰å±€å‹¢ï¼Œå»ºè­°æ‚¨å„ªå…ˆæ“´å¼µé ˜åœ°ä¸¦é—œæ³¨ç¾é‡‘æµï¼Œä¸è¦éåº¦æ§“æ¡¿ã€‚(æ¨¡æ“¬å»ºè­°)");
                            else resolve("AI è§€å¯Ÿä¸­...(æ¨¡æ“¬å›æ‡‰)");
                        }, 1000);
                    });
                }
                
                // 10. Error Handling
                try {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${userKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                    });
                    if (!response.ok) throw new Error(`API Error: ${response.status}`);
                    const data = await response.json();
                    const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    // 17. XSS Prevention
                    return DOMPurify.sanitize(text || "AI æš«æ™‚ç„¡æ³•å›æ‡‰");
                } catch (error) {
                    console.error("Gemini API Error:", error);
                    return "é€£ç·šéŒ¯èª¤æˆ– Key ç„¡æ•ˆï¼Œè«‹æª¢æŸ¥è¨­å®šã€‚";
                }
            }
        };

        // --- Main Component ---
        const App = () => {
            // --- Global State ---
            // 1. API Key Risk: Store in state, not code
            const [userApiKey, setUserApiKey] = useState(() => localStorage.getItem('esgame_api_key') || '');
            const [showSettings, setShowSettings] = useState(false);

            const [deck, setDeck] = useState([]);
            const [eventDeck, setEventDeck] = useState([]);
            const [board, setBoard] = useState(Array(100).fill(null));
            const [companies, setCompanies] = useState(COMPANIES_DATA.map(c => ({ 
                ...c, size: 0, greenCount: 0, active: false, price: 0, esgTier: 'C', esgMult: 0 
            })));
            
            const [players, setPlayers] = useState([]); // Initialized in useEffect
            const [currentPlayerIdx, setCurrentPlayerIdx] = useState(0);
            const [gamePhase, setGamePhase] = useState('INIT'); // INIT, PLACE, BUY, GAME_OVER
            const [selectedTileIndex, setSelectedTileIndex] = useState(null);
            const [logs, setLogs] = useState([]);
            const [turnStocksBought, setTurnStocksBought] = useState(0);
            const [winners, setWinners] = useState([]);
            const [turnCounter, setTurnCounter] = useState(1);
            
            // Events
            const [activeEvent, setActiveEvent] = useState(null); // Object with duration
            const [showEventModal, setShowEventModal] = useState(null);

            // AI
            const [aiAdvice, setAiAdvice] = useState(null);
            const [isAiLoading, setIsAiLoading] = useState(false);
            const [aiNews, setAiNews] = useState("");
            const [aiSummary, setAiSummary] = useState("");

            // --- 7. Optimize Current Player Access ---
            const currentPlayer = useMemo(() => players[currentPlayerIdx], [players, currentPlayerIdx]);

            const addLog = (msg) => {
                setLogs(prev => [`[T${turnCounter}] ${msg}`, ...prev].slice(0, 50));
            };

            // --- 2. Initialization Logic Fix ---
            useEffect(() => {
                const initGame = () => {
                    const fullDeck = shuffleArray(Array.from({ length: 100 }, (_, i) => i));
                    const p1Hand = fullDeck.splice(0, CONSTANTS.HAND_SIZE).sort((a,b)=>a-b);
                    const p2Hand = fullDeck.splice(0, CONSTANTS.HAND_SIZE).sort((a,b)=>a-b);
                    const p3Hand = fullDeck.splice(0, CONSTANTS.HAND_SIZE).sort((a,b)=>a-b);
                    
                    setDeck(fullDeck);
                    setEventDeck(shuffleArray(REGULATION_CARDS));
                    
                    const initialStocks = COMPANIES_DATA.reduce((acc, c) => ({ ...acc, [c.id]: 0 }), {});
                    
                    // Single setPlayers call
                    setPlayers([
                        { id: 0, name: 'ç©å®¶ 1', money: CONSTANTS.INITIAL_MONEY, stocks: {...initialStocks}, hand: p1Hand },
                        { id: 1, name: 'ç©å®¶ 2', money: CONSTANTS.INITIAL_MONEY, stocks: {...initialStocks}, hand: p2Hand },
                        { id: 2, name: 'ç©å®¶ 3', money: CONSTANTS.INITIAL_MONEY, stocks: {...initialStocks}, hand: p3Hand },
                    ]);
                    setGamePhase('PLACE');
                    addLog('éŠæˆ²é–‹å§‹ï¼');
                };
                initGame();
            }, []);

            // --- Pure Logic for Calculations ---
            const calculateCompanyStats = (size, greenCount, companyId, currentEvent) => {
                if (size === 0) return { price: 0, esgTier: 'C', esgMult: 0 };
                
                let basePrice = 0;
                if (size === 2) basePrice = 200;
                else if (size === 3) basePrice = 300;
                else if (size === 4) basePrice = 400;
                else if (size === 5) basePrice = 500;
                else if (size >= 6 && size <= 10) basePrice = 600;
                else if (size >= 11 && size <= 20) basePrice = 700;
                else if (size >= 21 && size <= 30) basePrice = 800;
                else if (size >= 31 && size <= 40) basePrice = 900;
                else basePrice = 1000;

                const greenRatio = greenCount / size;
                let esgMult = 1.0;
                let esgTier = 'B';
                if (greenRatio < 0.2) { esgMult = 0.8; esgTier = 'C'; }
                else if (greenRatio > 0.5) { esgMult = 1.5; esgTier = 'A'; }
                else { esgMult = 1.0; esgTier = 'B'; }

                let finalPrice = Math.floor(basePrice * esgMult);

                if (currentEvent) {
                    if (currentEvent.effectType === 'PRICE_MOD' && esgTier === currentEvent.targetTier) finalPrice += currentEvent.amount;
                    else if (currentEvent.effectType === 'PRICE_MOD_MULTI' && currentEvent.targetTiers.includes(esgTier)) finalPrice += currentEvent.amount;
                    else if (currentEvent.effectType === 'PRICE_MOD_ALL') finalPrice += currentEvent.amount;
                    else if (currentEvent.effectType === 'SCANDAL_B' && companyId === currentEvent.targetCompanyId) finalPrice += currentEvent.amount;
                    else if (currentEvent.effectType === 'RESTRICT_AND_DROP' && esgTier === currentEvent.targetTier) finalPrice += currentEvent.amount;
                }

                return { price: Math.max(0, finalPrice), esgTier, esgMult };
            };

            // 3. UpdateCompanies as Pure Function Logic
            // Returns the new companies state, doesn't rely on existing 'companies' state for calculations
            const getUpdatedCompaniesState = (currentBoard, currentEvent) => {
                return COMPANIES_DATA.map(c => {
                    let size = 0;
                    let greenCount = 0;
                    currentBoard.forEach(cell => {
                        if (cell && cell.ownerId === c.id) {
                            size++;
                            if (cell.type === 'green') greenCount++;
                        }
                    });
                    
                    if (size === 0) {
                        return { ...c, size: 0, greenCount: 0, active: false, price: 0, esgTier: 'C', esgMult: 0 };
                    }
                    
                    const stats = calculateCompanyStats(size, greenCount, c.id, currentEvent);
                    return { ...c, size, greenCount, active: true, price: stats.price, esgTier: stats.esgTier, esgMult: stats.esgMult };
                });
            };

            const getNeighbors = (index) => {
                const neighbors = [];
                const row = Math.floor(index / CONSTANTS.GRID_SIZE);
                const col = index % CONSTANTS.GRID_SIZE;
                if (row > 0) neighbors.push(index - CONSTANTS.GRID_SIZE); 
                if (row < CONSTANTS.GRID_SIZE - 1) neighbors.push(index + CONSTANTS.GRID_SIZE); 
                if (col > 0) neighbors.push(index - 1); 
                if (col < CONSTANTS.GRID_SIZE - 1) neighbors.push(index + 1); 
                return neighbors;
            };

            // --- Game Action Handlers (Refactored) ---
            
            const handlePlaceTile = (type) => { 
                if (selectedTileIndex === null || !currentPlayer) return;
                
                // 13. Dynamic Costs
                const greenCost = (activeEvent && activeEvent.effectType === 'COST_MOD') ? activeEvent.cost : CONSTANTS.BASE_GREEN_COST;
                const greySubsidy = (activeEvent && activeEvent.effectType === 'GREY_SUBSIDY') ? activeEvent.amount : 0;
                
                if (type === 'green' && currentPlayer.money < greenCost) { 
                    alert(`è³‡é‡‘ä¸è¶³ï¼æˆæœ¬ $${greenCost}`); 
                    return; 
                }

                // Copy state
                const nextPlayers = [...players];
                const activePlayer = { ...nextPlayers[currentPlayerIdx] };
                activePlayer.stocks = { ...activePlayer.stocks };
                activePlayer.hand = [...activePlayer.hand];

                // Deduct cost / Add subsidy
                if (type === 'green') { 
                    activePlayer.money -= greenCost; 
                    addLog(`${activePlayer.name} æŠ•è³‡ $${greenCost} å»ºè¨­ç¶ è‰²è£½ç¨‹`); 
                } else { 
                    activePlayer.money += greySubsidy; 
                    addLog(`${activePlayer.name} å»ºè¨­ç°è‰²è£½ç¨‹${greySubsidy>0?`ç²è£œè²¼ $${greySubsidy}`:''}`); 
                }

                // Remove tile from hand
                activePlayer.hand = activePlayer.hand.filter(t => t !== selectedTileIndex);
                nextPlayers[currentPlayerIdx] = activePlayer;

                // Analyze placement
                const neighbors = getNeighbors(selectedTileIndex);
                const neighborCompanies = new Set();
                const neighborTiles = [];
                neighbors.forEach(n => {
                    if (board[n]) {
                        if (board[n].ownerId) neighborCompanies.add(board[n].ownerId);
                        else neighborTiles.push(n);
                    }
                });

                let newBoard = [...board];
                let newCompanies = [...companies]; // Use current companies for reference, will update later

                // --- 15. Refactored Logic Branching ---
                if (neighborCompanies.size === 0 && neighborTiles.length === 0) {
                    // Isolated tile
                    newBoard[selectedTileIndex] = { ownerId: null, type };
                } else if (neighborCompanies.size === 0 && neighborTiles.length > 0) {
                    // New Company
                    handleNewCompany(newBoard, neighborTiles, type, activePlayer);
                } else if (neighborCompanies.size === 1) {
                    // Expansion
                    const companyId = [...neighborCompanies][0];
                    newBoard[selectedTileIndex] = { ownerId: companyId, type };
                    neighborTiles.forEach(t => { newBoard[t].ownerId = companyId; });
                } else {
                    // Merger
                    handleMerger(newBoard, neighborCompanies, type, nextPlayers, activePlayer);
                }

                // Finalize State Update
                // 3. Sync Logic: Calculate companies based on NEW board
                const finalCompanies = getUpdatedCompaniesState(newBoard, activeEvent);
                
                setBoard(newBoard);
                setCompanies(finalCompanies);
                setPlayers(nextPlayers);
                setGamePhase('BUY');
                setTurnStocksBought(0);
                setSelectedTileIndex(null);
                setAiAdvice(null);
            };

            const handleNewCompany = (currentBoard, neighborTiles, type, playerRef) => {
                const availableCompany = companies.find(c => !c.active && c.size === 0);
                if (availableCompany) {
                    const newOwnerId = availableCompany.id;
                    currentBoard[selectedTileIndex] = { ownerId: newOwnerId, type };
                    neighborTiles.forEach(t => { currentBoard[t].ownerId = newOwnerId; });
                    playerRef.stocks[newOwnerId] = (playerRef.stocks[newOwnerId] || 0) + CONSTANTS.FOUNDER_BONUS_STOCK;
                    addLog(`${playerRef.name} æˆç«‹ ${availableCompany.name} (ç²è´ˆ1å¼µ)`);
                } else {
                    currentBoard[selectedTileIndex] = { ownerId: null, type };
                    addLog(`${playerRef.name} æ”¾ç½®äº†ä¸€å¡Šç„¡ä¸»åœ° (ç„¡å¯ç”¨å…¬å¸)`);
                }
            };

            // 4. Merger Logic (P1)
            const handleMerger = (currentBoard, neighborCompaniesIds, type, allPlayers, activePlayer) => {
                const connectedIds = [...neighborCompaniesIds];
                const involvedCompanies = companies.filter(c => connectedIds.includes(c.id));
                
                // Sort by default power (Size desc)
                involvedCompanies.sort((a, b) => b.size - a.size);
                
                let winner = involvedCompanies[0];
                const potentialHostiles = [];

                // Check for Green Hegemony (Hostile Takeover)
                // Logic: A smaller company can eat a larger one if size diff <= 3 AND smaller has BETTER ESG tier
                for (let i = 1; i < involvedCompanies.length; i++) {
                    const candidate = involvedCompanies[i];
                    const sizeDiff = winner.size - candidate.size; // winner is always larger or equal due to sort
                    
                    const winnerEsgVal = getEsgValue(winner.esgTier);
                    const candidateEsgVal = getEsgValue(candidate.esgTier);

                    if (sizeDiff <= CONSTANTS.HOSTILE_TAKEOVER_SIZE_DIFF && candidateEsgVal > winnerEsgVal) {
                        potentialHostiles.push(candidate);
                    }
                }

                let isHostile = false;
                if (potentialHostiles.length > 0) {
                    // If multiple hostiles, pick the one with best ESG, then Size
                    potentialHostiles.sort((a, b) => {
                        const esgDiff = getEsgValue(b.esgTier) - getEsgValue(a.esgTier);
                        if (esgDiff !== 0) return esgDiff;
                        return b.size - a.size;
                    });
                    winner = potentialHostiles[0];
                    isHostile = true;
                    addLog(`ğŸ”¥ è§¸ç™¼ã€ç¶ è‰²éœ¸æ¬Šã€‘ï¼${winner.name} æƒ¡æ„ä½µè³¼äº†å¤§ä¼æ¥­ï¼`);
                }

                const losers = involvedCompanies.filter(c => c.id !== winner.id);

                // AI News
                generateAiNews(winner.name, losers.map(c => c.name).join('èˆ‡'), isHostile);

                // Compensation
                losers.forEach(loser => {
                    const bonusPool = loser.price * CONSTANTS.MERGER_BONUS_MULTIPLIER;
                    
                    // Find shareholders
                    const shareholders = allPlayers.map((p, idx) => ({ pIdx: idx, count: p.stocks[loser.id] || 0 })).filter(s => s.count > 0);
                    shareholders.sort((a, b) => b.count - a.count);

                    // Major/Minor bonus
                    if (shareholders.length > 0) {
                        let bonus1 = Math.floor(bonusPool * 0.6); 
                        if (loser.esgTier === 'C') bonus1 = Math.floor(bonus1 * 0.8);
                        allPlayers[shareholders[0].pIdx].money += bonus1;
                        addLog(`${allPlayers[shareholders[0].pIdx].name} ç² ${loser.name} æœ€å¤§è‚¡æ±è£œå„Ÿ $${bonus1}`);
                    }
                    if (shareholders.length > 1) {
                        let bonus2 = Math.floor(bonusPool * 0.3); 
                        if (loser.esgTier === 'C') bonus2 = Math.floor(bonus2 * 0.8);
                        allPlayers[shareholders[1].pIdx].money += bonus2;
                        addLog(`${allPlayers[shareholders[1].pIdx].name} ç² ${loser.name} äºŒè‚¡æ±è£œå„Ÿ $${bonus2}`);
                    }

                    // Sell stocks at current price
                    allPlayers.forEach(p => {
                        const count = p.stocks[loser.id];
                        if (count > 0) {
                            p.money += count * loser.price;
                            p.stocks[loser.id] = 0;
                        }
                    });
                });

                // Update Board
                currentBoard[selectedTileIndex] = { ownerId: winner.id, type };
                
                // Convert tiles
                const loserIds = losers.map(l => l.id);
                // We need to convert neighbor unowned tiles AND loser tiles
                currentBoard.forEach((cell, idx) => {
                    if (!cell) return;
                    if (loserIds.includes(cell.ownerId)) {
                        currentBoard[idx] = { ...cell, ownerId: winner.id };
                    }
                });
                // Also convert unowned neighbors (orphans attached to the merger tile)
                const neighbors = getNeighbors(selectedTileIndex);
                neighbors.forEach(n => {
                    if (currentBoard[n] && !currentBoard[n].ownerId) {
                        currentBoard[n].ownerId = winner.id;
                    }
                });
            };

            const getEsgValue = (tier) => {
                if (tier === 'A') return 3;
                if (tier === 'B') return 2;
                return 1;
            };

            // --- Buying Stocks ---
            const handleBuyStock = (companyId) => {
                // 11. Input Validation
                const company = companies.find(c => c.id === companyId);
                if (!company) return;

                if (activeEvent && activeEvent.effectType === "RESTRICT_AND_DROP" && company.esgTier === 'C') { 
                    alert("æ³•è¦é™åˆ¶ï¼šç›®å‰ç¦æ­¢è²·å…¥ C ç´šå…¬å¸ï¼"); return; 
                }
                if (turnStocksBought >= CONSTANTS.MAX_STOCKS_PER_TURN) { alert("æœ¬å›åˆæœ€å¤šè³¼è²· 3 å¼µï¼"); return; }
                if (!company.active) { alert("å…¬å¸æœªæˆç«‹ï¼"); return; }
                
                const currentMoney = players[currentPlayerIdx].money;
                if (currentMoney < company.price) { alert("è³‡é‡‘ä¸è¶³ï¼"); return; }

                setPlayers(prev => {
                    const next = [...prev];
                    const p = { ...next[currentPlayerIdx] };
                    p.stocks = { ...p.stocks };
                    p.money -= company.price;
                    p.stocks[companyId] = (p.stocks[companyId] || 0) + 1;
                    next[currentPlayerIdx] = p;
                    return next;
                });
                setTurnStocksBought(prev => prev + 1);
            };

            // --- Events Logic ---
            const triggerEvent = () => {
                if (eventDeck.length === 0) {
                    addLog("æ³•è¦äº‹ä»¶å¡å·²ç”¨ç›¡ï¼Œé‡æ–°æ´—ç‰Œï¼");
                    setEventDeck(shuffleArray(REGULATION_CARDS));
                }

                const newEventDeck = [...eventDeck];
                const card = newEventDeck.pop();
                setEventDeck(newEventDeck);
                
                // 5. Event Persistence & Duration
                const eventDuration = card.duration || CONSTANTS.EVENT_DEFAULT_DURATION;
                
                addLog(`âš¡ è§¸ç™¼æ³•è¦äº‹ä»¶ï¼šã€${card.title}ã€‘(æŒçºŒ ${card.instant ? 0 : eventDuration} å›åˆ)`);
                setShowEventModal(card);
                handleEventEffect(card, eventDuration);
            };

            const handleEventEffect = (card, duration) => {
                let newPlayers = [...players];
                const currentCompanies = getUpdatedCompaniesState(board, card); // Preview effect

                if (card.instant) {
                    switch (card.effectType) {
                        case "FINE":
                            newPlayers = newPlayers.map(p => {
                                let fine = 0;
                                currentCompanies.forEach(c => {
                                    if (c.active && c.esgTier === card.targetTier) fine += (p.stocks[c.id] || 0) * card.amount;
                                });
                                if (fine > 0) {
                                    addLog(`${p.name} è¢«ç½°æ¬¾ $${fine}`);
                                    return { ...p, money: Math.max(0, p.money - fine) };
                                }
                                return p;
                            });
                            break;
                        case "SUBSIDY_MAJOR":
                            currentCompanies.forEach(c => {
                                if (c.active && c.esgTier === card.targetTier) {
                                    const shareholders = newPlayers.map((p, idx) => ({ idx, count: p.stocks[c.id] || 0 })).sort((a, b) => b.count - a.count);
                                    if (shareholders[0].count > 0) {
                                        newPlayers[shareholders[0].idx].money += card.amount;
                                        addLog(`${newPlayers[shareholders[0].idx].name} ç² ${c.name} è£œåŠ© $${card.amount}`);
                                    }
                                }
                            });
                            break;
                        case "BONUS_MOST_A":
                            const aCounts = newPlayers.map((p, idx) => {
                                let count = 0;
                                currentCompanies.forEach(c => { if (c.active && c.esgTier === 'A') count += (p.stocks[c.id] || 0); });
                                return { idx, count };
                            }).sort((a, b) => b.count - a.count);
                            if (aCounts[0].count > 0) {
                                newPlayers[aCounts[0].idx].money += card.amount;
                                addLog(`${newPlayers[aCounts[0].idx].name} ç²ç $${card.amount}`);
                            }
                            break;
                        case "DIVIDEND":
                             newPlayers = newPlayers.map(p => {
                                let bonus = 0;
                                currentCompanies.forEach(c => { if (c.active && c.esgTier === card.targetTier) bonus += (p.stocks[c.id] || 0) * card.amount; });
                                if (bonus > 0) return { ...p, money: p.money + bonus };
                                return p;
                            });
                            break;
                    }
                    setPlayers(newPlayers);
                    // Instant events don't persist
                    setActiveEvent(null);
                } else {
                    // Persistent events
                    const eventObj = { ...card, remainingTurns: duration };
                    
                    if (card.effectType === 'SCANDAL_B') {
                        const bCompanies = currentCompanies.filter(c => c.active && c.esgTier === 'B').sort((a, b) => b.size - a.size);
                        eventObj.targetCompanyId = bCompanies.length > 0 ? bCompanies[0].id : null;
                    }
                    
                    setActiveEvent(eventObj);
                    // Need to update companies prices immediately because event is active
                    setCompanies(getUpdatedCompaniesState(board, eventObj));
                }
            };

            const endTurn = () => {
                // 9. Loading/Transition UX could be here, but simple logic is fast enough
                if (deck.length === 0) {
                    if (confirm("ç‰Œåº«å·²ç©ºï¼çµæŸéŠæˆ²ï¼Ÿ")) calculateFinalScores();
                    return;
                }

                // Handle Event Duration
                let nextEvent = activeEvent;
                if (activeEvent) {
                    if (activeEvent.remainingTurns > 1) {
                        nextEvent = { ...activeEvent, remainingTurns: activeEvent.remainingTurns - 1 };
                        setActiveEvent(nextEvent);
                    } else {
                        addLog(`äº‹ä»¶ã€${activeEvent.title}ã€‘æ•ˆæœçµæŸã€‚`);
                        setActiveEvent(null);
                        nextEvent = null;
                    }
                }

                // Update company prices if event changed
                setCompanies(getUpdatedCompaniesState(board, nextEvent));

                const newDeck = [...deck];
                const draw = newDeck.pop();
                setDeck(newDeck);
                
                setPlayers(prev => {
                    const next = prev.map(p => ({ ...p }));
                    next[currentPlayerIdx].hand = [...next[currentPlayerIdx].hand, draw].sort((a,b)=>a-b);
                    return next;
                });

                const newCounter = turnCounter + 1;
                setTurnCounter(newCounter);
                
                // Trigger event every Interval turns
                if (newCounter % CONSTANTS.EVENT_INTERVAL === 0) {
                    // Use timeout to let render finish before modal
                    setTimeout(triggerEvent, 100);
                }

                setCurrentPlayerIdx((currentPlayerIdx + 1) % players.length);
                setGamePhase('PLACE');
                setAiAdvice(null);
            };

            // 6. Fix Final Scoring (Use fresh data)
            const calculateFinalScores = () => {
                addLog("æ­£åœ¨çµç®—è³‡ç”¢...");
                // Recalculate one last time to be safe
                const finalCompaniesState = getUpdatedCompaniesState(board, null); // No events in final score? Or keep active? Usually clear.
                
                const finalPlayers = players.map(p => {
                    let stockValue = 0;
                    finalCompaniesState.forEach(c => {
                        const count = p.stocks?.[c.id] || 0;
                        if (c.active) {
                            stockValue += count * c.price;
                        }
                    });
                    return { ...p, stockValue, totalAssets: p.money + stockValue };
                });
                
                finalPlayers.sort((a, b) => b.totalAssets - a.totalAssets);
                setWinners(finalPlayers);
                setGamePhase('GAME_OVER');
                
                generateGameOverSummary(finalPlayers).catch(console.error);
            };

            // --- AI Functions ---
            const generateAiAdvice = async () => {
                setIsAiLoading(true);
                setAiAdvice("");
                const p = currentPlayer;
                const gameState = {
                    phase: gamePhase,
                    event: activeEvent ? activeEvent.title : "ç„¡",
                    money: p.money,
                    hand: p.hand.map(h => getCoordString(h)),
                    topCompanies: companies.filter(c => c.active).sort((a,b)=>b.price - a.price).slice(0,3).map(c=>`${c.name}($${c.price})`)
                };
                const prompt = `ä½ æ˜¯ã€Šæ·¨é›¶è³½å±€ã€‹é¡§å•ã€‚ç›®å‰äº‹ä»¶ï¼š${gameState.event}ã€‚ç©å®¶æœ‰$${gameState.money}ã€‚æ‰‹ç‰Œï¼š${JSON.stringify(gameState.hand)}ã€‚é«˜åƒ¹è‚¡ï¼š${JSON.stringify(gameState.topCompanies)}ã€‚è«‹çµ¦å‡ºç°¡çŸ­ç­–ç•¥å»ºè­°(50å­—å…§)ã€‚`;
                
                const result = await AiService.callGemini(prompt, userApiKey);
                setAiAdvice(result);
                setIsAiLoading(false);
            };

            const generateAiNews = async (winner, loser, isHostile) => {
                const prompt = `æ’°å¯«ä¸€å‰‡è²¡ç¶“å¿«è¨Šï¼š${winner} å‰›å‰›${isHostile ? 'æƒ¡æ„ä½µè³¼' : 'ä½µè³¼'}äº† ${loser}ã€‚è«‹ç”¨è³å‹•ã€è«·åˆºçš„èªæ°£å¯«æ¨™é¡Œ(30å­—å…§)ã€‚`;
                const result = await AiService.callGemini(prompt, userApiKey);
                setAiNews(result);
                setTimeout(() => setAiNews(""), 8000);
            };

            const generateGameOverSummary = async (rankedPlayers) => {
                const winner = rankedPlayers[0];
                const prompt = `éŠæˆ²çµæŸã€‚å† è»æ˜¯${winner.name}ï¼Œç¸½è³‡ç”¢$${winner.totalAssets}ã€‚è«‹å°é€™å ´æ¯”è³½å¯«ä¸€æ®µç¸½çµèˆ‡é»è©•(100å­—)ã€‚`;
                const result = await AiService.callGemini(prompt, userApiKey);
                setAiSummary(result);
            };

            const handleEndGameEarly = () => {
                if (window.confirm("ç¢ºå®šè¦æå‰çµæŸéŠæˆ²ä¸¦çµç®—ï¼Ÿ")) {
                    calculateFinalScores();
                }
            };

            const saveApiKey = (key) => {
                localStorage.setItem('esgame_api_key', key);
                setUserApiKey(key);
                setShowSettings(false);
                alert("Key å·²å„²å­˜ã€‚");
            };

            // --- Render Helpers ---
            if (!currentPlayer && gamePhase !== 'INIT') return <div>Loading...</div>;

            if (gamePhase === 'GAME_OVER') {
                return (
                    <div className="min-h-screen bg-gray-900 flex flex-col items-center justify-center p-4">
                        <div className="bg-white max-w-4xl w-full rounded-xl shadow-2xl p-8 my-8 animate-fade-in-up">
                            <h2 className="text-4xl font-bold text-center text-gray-800 mb-6">ğŸ† éŠæˆ²çµæŸ ğŸ†</h2>
                            <div className="space-y-4 mb-8">
                                {winners.map((p, idx) => (
                                    <div key={p.id} className={`flex items-center p-4 rounded-lg border-2 ${idx === 0 ? 'border-yellow-400 bg-yellow-50 transform scale-105 shadow-lg' : 'border-gray-200'}`}>
                                        <div className="text-2xl mr-4">{idx === 0 ? 'ğŸ¥‡' : (idx === 1 ? 'ğŸ¥ˆ' : 'ğŸ¥‰')}</div>
                                        <div className="flex-1">
                                            <div className="font-bold text-lg">{p.name}</div>
                                            <div className="text-sm text-gray-500">ç¾é‡‘: ${p.money} | è‚¡ç¥¨å¸‚å€¼: ${p.stockValue}</div>
                                        </div>
                                        <div className="text-2xl font-bold text-green-600">${p.totalAssets.toLocaleString()}</div>
                                    </div>
                                ))}
                            </div>
                            <div className="bg-purple-100 p-4 rounded-lg border border-purple-200 mb-6 text-purple-900 text-sm italic">
                                ğŸ¤– AI è³½è©•: {aiSummary || "åˆ†æä¸­..."}
                            </div>
                            <button onClick={() => window.location.reload()} className="w-full bg-blue-600 hover:bg-blue-700 text-white py-3 rounded-lg font-bold">å†ç©ä¸€å±€</button>
                        </div>
                    </div>
                );
            }

            return (
                <div className="min-h-screen flex flex-col p-2 sm:p-4 max-w-7xl mx-auto relative text-gray-800">
                    
                    {/* Settings Modal */}
                    {showSettings && (
                        <div className="fixed inset-0 bg-black bg-opacity-70 z-50 flex items-center justify-center">
                            <div className="bg-white p-6 rounded-lg shadow-xl max-w-md w-full">
                                <h3 className="font-bold text-lg mb-4">è¨­å®š</h3>
                                <label className="block text-sm font-medium mb-1">Gemini API Key (é¸å¡«)</label>
                                <input type="password" id="apiKeyInput" defaultValue={userApiKey} className="w-full border p-2 rounded mb-2" placeholder="è¼¸å…¥ Key ä»¥å•Ÿç”¨çœŸå¯¦ AI" />
                                <p className="text-xs text-gray-500 mb-4">å¦‚æœä¸è¼¸å…¥ï¼ŒéŠæˆ²å°‡ä½¿ç”¨å…§å»ºçš„æ¨¡æ“¬å›æ‡‰ã€‚Key åƒ…å„²å­˜åœ¨æ‚¨çš„ç€è¦½å™¨ä¸­ã€‚</p>
                                <div className="flex justify-end gap-2">
                                    <button onClick={() => setShowSettings(false)} className="px-4 py-2 text-gray-600">å–æ¶ˆ</button>
                                    <button onClick={() => saveApiKey(document.getElementById('apiKeyInput').value)} className="px-4 py-2 bg-blue-600 text-white rounded">å„²å­˜</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Event Modal */}
                    {showEventModal && (
                        <div className="fixed inset-0 bg-black bg-opacity-60 z-50 flex items-center justify-center p-4">
                            <div className="bg-white rounded-xl shadow-2xl max-w-sm w-full overflow-hidden animate-pulse-fast" style={{animationIterationCount: 1}}>
                                <div className="bg-gradient-to-r from-red-600 to-orange-600 p-4 text-white text-center font-bold text-xl">âš–ï¸ æ³•è¦è®Šå‹•</div>
                                <div className="p-6 text-center">
                                    <h3 className="text-2xl font-bold text-gray-800 mb-2">{showEventModal.title}</h3>
                                    <p className="text-gray-600 mb-4">{showEventModal.desc}</p>
                                    <div className="bg-orange-50 p-3 rounded text-sm font-mono text-orange-800 border border-orange-200">
                                        {showEventModal.instant ? "âš¡ ç«‹å³æ•ˆæœ" : `â³ æŒçºŒ ${showEventModal.duration || CONSTANTS.EVENT_DEFAULT_DURATION} å›åˆ`}
                                    </div>
                                    <button onClick={() => setShowEventModal(null)} className="mt-6 bg-gray-800 text-white py-2 px-8 rounded-full hover:bg-black font-bold shadow transition">äº†è§£</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* AI News Ticker */}
                    {aiNews && (
                        <div className="fixed top-4 right-4 z-40 bg-gray-900 text-white p-4 rounded shadow-xl border-l-4 border-yellow-400 max-w-md animate-bounce-in">
                            <h4 className="text-yellow-400 text-xs font-bold tracking-wider">NEWS</h4>
                            <p className="text-sm font-medium mt-1">{aiNews}</p>
                        </div>
                    )}

                    {/* Header */}
                    <header className="mb-4 bg-white p-3 rounded-lg shadow-sm flex justify-between items-center border border-gray-100">
                        <div>
                            <h1 className="text-xl sm:text-2xl font-bold text-gray-800 tracking-tight">æ·¨é›¶è³½å±€ <span className="text-green-600">Green Merger</span></h1>
                            {activeEvent ? (
                                <div className="text-xs bg-red-100 text-red-700 px-2 py-1 rounded inline-block mt-1 font-bold animate-pulse">
                                    ğŸ”¥ {activeEvent.title} (å‰© {activeEvent.remainingTurns} å›åˆ)
                                </div>
                            ) : <div className="text-xs text-gray-400 mt-1">ç›®å‰ç„¡ç‰¹æ®Šæ³•è¦</div>}
                        </div>
                        <div className="flex items-center gap-4">
                             <button onClick={() => setShowSettings(true)} className="text-gray-400 hover:text-gray-600">âš™ï¸</button>
                             <div className="text-right">
                                <div className="font-bold text-lg text-blue-600">{currentPlayer?.name}</div>
                                <div className="text-xs text-gray-500">Round {turnCounter}</div>
                            </div>
                        </div>
                    </header>

                    <div className="flex flex-col lg:flex-row gap-6">
                        {/* Left Column: Board */}
                        <div className="flex-none flex flex-col items-center">
                            <div className="bg-white p-3 rounded shadow-lg border border-gray-200 mx-auto relative">
                                <div className="tile-grid w-[320px] h-[320px] sm:w-[480px] sm:h-[480px]">
                                    {board.map((cell, idx) => (
                                        <Tile 
                                            key={idx} 
                                            index={idx} 
                                            cell={cell} 
                                            active={selectedTileIndex === idx}
                                            playable={gamePhase === 'PLACE' && currentPlayer?.hand.includes(idx)}
                                            onClick={() => { if (gamePhase === 'PLACE' && currentPlayer?.hand.includes(idx)) setSelectedTileIndex(idx); }}
                                            companies={companies}
                                        />
                                    ))}
                                </div>
                            </div>
                            <div className="w-full max-w-[480px] bg-gray-50 p-3 mt-4 rounded border h-40 overflow-y-auto text-xs font-mono shadow-inner scrollbar-thin">
                                {logs.map((l, i) => <div key={i} className="mb-1 border-b border-gray-200 pb-1 last:border-0">{l}</div>)}
                            </div>
                        </div>

                        {/* Right Column: Controls & Stats */}
                        <div className="flex-1 flex flex-col gap-4">
                            {/* Market Status */}
                            <div className="bg-white rounded shadow p-4 border border-gray-100">
                                <h3 className="font-bold text-gray-700 border-b pb-2 mb-2 flex justify-between">
                                    <span>ğŸ“ˆ è‚¡ç¥¨å¸‚å ´</span>
                                    <span className="text-xs font-normal text-gray-400 self-end">åƒ¹æ ¼èˆ‡ ESG é€£å‹•</span>
                                </h3>
                                <div className="grid grid-cols-2 md:grid-cols-4 gap-2">
                                    {companies.map(c => (
                                        <div key={c.id} className={`border rounded p-2 transition-all ${c.active ? c.lightColor : 'bg-gray-50 opacity-50 grayscale'}`}>
                                            <div className="flex justify-between items-start">
                                                <span className={`font-bold text-sm ${c.textColor}`}>{c.name}</span>
                                                {c.active && <span className={`text-[10px] px-1 rounded text-white ${c.esgTier==='A'?'bg-green-600':(c.esgTier==='B'?'bg-blue-500':'bg-gray-500')}`}>{c.esgTier}</span>}
                                            </div>
                                            <div className="mt-1 flex justify-between items-end">
                                                <div className="text-xs text-gray-500">
                                                    {c.active ? `æ¨¡:${c.size} ç¶ :${Math.round(c.greenCount/c.size*100)}%` : 'æœªä¸Šå¸‚'}
                                                </div>
                                                <div className="font-mono font-bold text-lg leading-none">${c.price}</div>
                                            </div>
                                            {gamePhase === 'BUY' && c.active && (
                                                <button 
                                                    onClick={() => handleBuyStock(c.id)} 
                                                    disabled={turnStocksBought >= CONSTANTS.MAX_STOCKS_PER_TURN || currentPlayer.money < c.price}
                                                    className="mt-2 w-full bg-gray-800 text-white text-xs rounded py-1.5 hover:bg-black disabled:opacity-20 transition-colors"
                                                >
                                                    è²·é€²
                                                </button>
                                            )}
                                        </div>
                                    ))}
                                </div>
                            </div>

                            {/* Control Panel */}
                            <div className={`bg-white rounded shadow p-4 border-t-4 transition-colors ${gamePhase === 'PLACE' ? 'border-green-500' : 'border-purple-500'}`}>
                                <div className="flex justify-between items-end mb-4">
                                    <div>
                                        <div className="text-xs text-gray-500 uppercase font-bold tracking-wider">{gamePhase === 'PLACE' ? 'è¡Œå‹•éšæ®µ' : 'æŠ•è³‡éšæ®µ'}</div>
                                        <span className="font-bold text-2xl text-gray-800">{currentPlayer?.name}</span>
                                    </div>
                                    <div className="text-right">
                                        <div className="text-xs text-gray-500">å¯ç”¨è³‡é‡‘</div>
                                        <span className="font-mono text-2xl text-green-700 font-bold">${currentPlayer?.money.toLocaleString()}</span>
                                    </div>
                                </div>
                                
                                {gamePhase === 'PLACE' && (
                                    <div className="animate-fade-in">
                                        <div className="mb-4">
                                            {!aiAdvice && !isAiLoading && <button onClick={generateAiAdvice} className="w-full bg-indigo-50 text-indigo-600 border border-indigo-200 py-2 rounded shadow-sm text-sm font-bold hover:bg-indigo-100 transition">âœ¨ è©¢å• AI é¡§å•</button>}
                                            {isAiLoading && <div className="text-center text-sm text-gray-500 shimmer p-2 rounded">AI æ­£åœ¨åˆ†æç›¤é¢...</div>}
                                            {aiAdvice && <div className="bg-indigo-50 p-3 rounded text-sm text-indigo-900 border border-indigo-200 relative"><button onClick={()=>setAiAdvice(null)} className="absolute top-1 right-2 text-indigo-300 hover:text-indigo-500">x</button>{aiAdvice}</div>}
                                        </div>
                                        
                                        {selectedTileIndex !== null ? (
                                            <div className="flex gap-2">
                                                <button onClick={() => handlePlaceTile('grey')} className="flex-1 bg-gray-600 hover:bg-gray-700 text-white py-3 rounded font-bold shadow transition flex flex-col items-center">
                                                    <span>ç°è‰²è£½ç¨‹</span>
                                                    <span className="text-[10px] font-normal opacity-80">{activeEvent?.effectType === 'GREY_SUBSIDY' ? `+è£œåŠ© $${activeEvent.amount}` : 'å…è²»'}</span>
                                                </button>
                                                <button onClick={() => handlePlaceTile('green')} className="flex-1 bg-green-600 hover:bg-green-700 text-white py-3 rounded font-bold shadow transition flex flex-col items-center">
                                                    <span>ç¶ è‰²è£½ç¨‹</span>
                                                    <span className="text-[10px] font-normal opacity-80">æˆæœ¬ ${activeEvent?.effectType === 'COST_MOD' ? activeEvent.cost : CONSTANTS.BASE_GREEN_COST}</span>
                                                </button>
                                            </div>
                                        ) : <div className="text-center py-4 bg-yellow-50 text-yellow-800 rounded border border-yellow-200 text-sm">ğŸ‘‡ è«‹å¾ä¸‹æ–¹é¸æ“‡ä¸€å¼µæ‰‹ç‰Œæ‰“å‡º</div>}
                                        
                                        <div className="mt-4 grid grid-cols-6 gap-2">
                                            {currentPlayer?.hand.map(h => (
                                                <button key={h} onClick={() => setSelectedTileIndex(h)} 
                                                    className={`py-2 border rounded font-mono text-sm transition-all
                                                    ${selectedTileIndex === h ? 'bg-blue-600 text-white ring-2 ring-blue-300 transform -translate-y-1' : 'bg-white hover:bg-gray-50 text-gray-700'}`}>
                                                    {getCoordString(h)}
                                                </button>
                                            ))}
                                        </div>
                                    </div>
                                )}

                                {gamePhase === 'BUY' && (
                                    <div className="text-center animate-fade-in">
                                        <p className="mb-4 text-sm text-gray-600">æœ¬å›åˆå·²è³¼è²·è‚¡ç¥¨: <span className="font-bold text-gray-900">{turnStocksBought} / {CONSTANTS.MAX_STOCKS_PER_TURN}</span></p>
                                        <button onClick={endTurn} className="w-full bg-red-600 hover:bg-red-700 text-white py-3 rounded font-bold text-lg shadow transition transform hover:scale-[1.02]">
                                            çµæŸå›åˆ
                                        </button>
                                        <button type="button" onClick={handleEndGameEarly} className="mt-4 text-xs text-gray-400 hover:underline hover:text-gray-600 w-full py-2">
                                            æå‰çµç®—éŠæˆ²
                                        </button>
                                    </div>
                                )}
                            </div>

                             {/* Portfolio */}
                             <div className="bg-white rounded-lg shadow p-4 border border-gray-100">
                                <h4 className="font-bold text-gray-700 mb-3 text-sm">ğŸ’¼ æŒè‚¡æ˜ç´°</h4>
                                <div className="grid grid-cols-3 gap-y-2 gap-x-4 text-sm">
                                    {companies.map(c => (
                                        <div key={c.id} className="flex justify-between items-center border-b border-gray-100 pb-1">
                                            <span className={`${c.textColor} font-medium text-xs`}>{c.name}</span>
                                            <span className={`font-mono font-bold px-1.5 rounded ${currentPlayer?.stocks[c.id] > 0 ? 'bg-gray-100 text-gray-800' : 'text-gray-300'}`}>
                                                {currentPlayer?.stocks[c.id] || 0}
                                            </span>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* Footer with Links and Message */}
                    <footer className="mt-8 pb-8 flex flex-col items-center gap-3">
                        <div className="flex flex-wrap justify-center gap-4">
                            <a 
                                href="https://www.google.com" 
                                target="_blank" 
                                rel="noopener noreferrer"
                                className="flex items-center gap-2 bg-white px-6 py-2 rounded-full shadow hover:shadow-md transition-all border border-gray-200 text-gray-600 font-medium hover:text-blue-600 group"
                            >
                                <svg className="w-5 h-5 group-hover:scale-110 transition-transform" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="#4285F4"/>
                                    <path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853"/>
                                    <path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05"/>
                                    <path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"/>
                                </svg>
                                Google
                            </a>

                            <a 
                                href="http://www.aifinsys.com." 
                                className="flex items-center gap-2 bg-white px-6 py-2 rounded-full shadow hover:shadow-md transition-all border border-gray-200 text-gray-600 font-medium hover:text-indigo-600 group"
                            >
                                <svg className="w-5 h-5 group-hover:scale-110 transition-transform" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
                                </svg>
                                Home
                            </a>
                        </div>
                        <div className="text-gray-400 text-sm font-medium tracking-wide mt-2">Ai Fintech Corp. 2025 Â© </div>
                    </footer>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>